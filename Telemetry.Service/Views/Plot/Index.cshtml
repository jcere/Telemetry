
@{
    ViewBag.Title = "Plot";
}

<h2>Plot</h2>

<script>

    $(document).ready(function () {
        $('#btnGetData').click(function () {
            $.ajax({
                type: 'GET',
                url: '@Url.RouteUrl("ActionApi", new { httproute = "", controller = "Temp" })',
                success: function (data) {
                    plotFunction1(data);
                },
                dataType: "json"
            });
        });
    });

    function plotFunction1(jsonObj) {

        var tempData = jsonObj.Data.Data;
        // jQuery.map:
        var y = tempData.map(function (v) {
            return v.TempC;
        });

        var x = tempData.map(function (v) {
            return v.DateTime;
        });

        var myLineChart = new Chart(ctx).Line(data, options);

        var data = {
            labels: ["January", "February", "March", "April", "May", "June", "July"],
            datasets: [
                {
                    label: "My First dataset",
                    fillColor: "rgba(220,220,220,0.2)",
                    strokeColor: "rgba(220,220,220,1)",
                    pointColor: "rgba(220,220,220,1)",
                    pointStrokeColor: "#fff",
                    pointHighlightFill: "#fff",
                    pointHighlightStroke: "rgba(220,220,220,1)",
                    data: [65, 59, 80, 81, 56, 55, 40]
                }
            ]
        };
    }


    function plotFunction(jsonObj) {

        var tempData = jsonObj.Data.Data;

        // define dimensions of graph
        var m = [80, 80, 80, 80]; // margins
        var w = 1000 - m[1] - m[3]; // width
        var h = 400 - m[0] - m[2]; // height

        // create a simple data array that we'll plot with a line (this array represents only the Y values, 
        // X will just be the index location) jQuery.map:
        var data = tempData.map(function (v) {
            return v.TempC;
        });

        // X scale will fit all values from data[] within pixels 0-w
        var x = d3.scale.linear().domain([0, data.length]).range([0, w]);
        // Y scale will fit values from 0-10 within pixels h-0 (Note the inverted domain for the y-scale: bigger is up!)
        var y = d3.scale.linear().domain([10, 125]).range([h, 0]);

        // create a line function that can convert data[] into x and y points
        var line = d3.svg.line()
			// assign the X function to plot our line as we wish
			.x(function (d, i) {
			    // return the X coordinate where we want to plot this datapoint     
			    return x(i);
			})
			.y(function (d) {
                // return the Y coordinate where we want to plot this datapoint
			    return y(d);
			})

        // Add an SVG element with the desired dimensions and margin.
        var graph = d3.select("#output").append("svg:svg")
              .attr("width", w + m[1] + m[3])
              .attr("height", h + m[0] + m[2])
            .append("svg:g")
              .attr("transform", "translate(" + m[3] + "," + m[0] + ")");

        // create yAxis
        var xAxis = d3.svg.axis().scale(x).tickSize(-h).tickSubdivide(true);
        // Add the x-axis.
        graph.append("svg:g")
              .attr("class", "x axis")
              .attr("transform", "translate(0," + h + ")")
              .call(xAxis);


        // create left yAxis
        var yAxisLeft = d3.svg.axis().scale(y).ticks(4).orient("left");
        // Add the y-axis to the left
        graph.append("svg:g")
              .attr("class", "y axis")
              .attr("transform", "translate(-25,0)")
              .call(yAxisLeft);

        // Add the line by appending an svg:path element with the data line we created above
        // do this AFTER the axes above so that the line is above the tick-lines
        graph.append("svg:path").attr("d", line(data));

        // automatically determining max range can work something like this
        // var y = d3.scale.linear().domain([0, d3.max(data)]).range([h, 0]);
    };

</script>
<div id="output">
</div>
<p>
    <input id="btnGetData" type="button" value="Get Data" />
</p>

